JVM支持两种类型的类加载器(引导类加载器、自定义类加载器)

在Java虚拟机规范中定义：将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。


常见的类加载器始终只有下图的常见的三个:

![类加载器分类.png](..%2Fimages%2F01-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB.png)

用户自定义类加载器、系统类加载器、扩展类加载器、启动类加载器的关系是包含关系，并非继承关系，可以理解为上下级关系。

对于用户自定义类来说，默认使用系统类加载器进行加载。


## 启动类加载器
- 这个类的加载使用c/c++语言实现的，嵌套在JVM内部。
- 该加载器用来加载Java核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或者sun.boot.class.path路径下的内容，用于提供JVM自身需要的类)
- 并不继承自java.lang.ClassLoader，没有父加载器
- 加载扩展类和应用程序类加载器，并指定为他们的父加载器。
- 出于安全的角度，启动类加载器只加载包名为java、javax、sun等开头的类。

## 扩展类加载器
- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
- 派生于ClassLoader类。
- 父类加载器为启动类加载器。
- 从java.ext.dirs系统属性所指定的目录中加载类库。如果用户创建的Jar放在此目录下，也会自动由扩展类加载器加载。

## 应用程序类加载器(系统类加载器, AppClassLoader)
- java语言编写，由sun.misc.Launcher$AppClassLoader实现。
- 派生于ClassLoader类。
- 父类加载器为扩展类加载器。
- 负责加载环境变量下classpath或者系统属性java.class.path指定路径下的类库。
- 该类加载是程序中默认的类加载器，一般而言，Java应用的类都是由该类加载器完成加载。
- 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。


## 用户自定义加载器
在日常的应用程序开发中，类的加载几乎是右上述3种加载器相互配合执行。在有必要的时候，可以自定义类加载器。


### 为什么需要自定义类加载器？
- 隔离加载类(把不同的类加载到不同的环境中，确保应用的Jar不会冲突)
- 修改类加载的方式(在需要的时候进行动态加载)
- 扩展加载源(加载的jar不一定来自本地，有可能来自网络、数据库、电视机机顶盒等等)
- 防止源码泄露

### 自定义类加载器实现步骤
- 可以通过继承抽象类java.lang.classLoader类的方式，实现 自己的类加载器，以满足一些特殊的需求 
- 在JDK1.2之后建议把自定义的类加载逻辑写在findClass()方法中 
- 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。